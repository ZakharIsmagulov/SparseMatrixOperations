# SparseMatrixOperations

## Задача и описание
Простые операции с разреженными матрицами + OpenMP. Попробовать разные форматы хранения матрицы.

Реализованы структуры матриц:

- Dense Matrix
- COO Matrix (Coordinate list)
- CSR Matrix (Compressed Sparse Row)
- CSC Matrix (Compressed Sparse Column)

и следующие операции:

- умножение на скаляр
- умножение на вектор
- транспонирование
- сложение двух матриц одного формата

Для каждой структуры данные операции выполнены в двух вариантах:

- последовательном
- параллельном (OpenMP)

**Цель** — определить, как тип хранения и распараллеливание влияют на производительность.

## Структуры данных

### DenseMatrix:

Плотная матрица, хранящаяся в виде непрерывного массива элементов

### COOMatrix:

Разреженный формат хранения в виде трёх массивов одинаковой длины:
- row_idx_[i] — номер строки ненулевого элемента
- col_idx_[i] — номер столбца
- val_[i] — значение

### CSRMatrix:

Хранит ненулевые элементы построчно:
- row_ptr_[] — индексы начала строк
- col_idx_[] — столбцы
- val_[] — значения

**Запись и хранение элементов в строгом порядке: элементы по неубыванию строк и возрастанию столбцов**

### CSCMatrix:

Аналог CSR, но по столбцам:
- col_ptr_[]
- row_idx_[]
- val_[]

**Запись и хранение элементов в строгом порядке: элементы по неубыванию столбцов и возрастанию строк**

## Схема тестирования и валидации

1. Функциональная валидация (validity_check.cpp):
	На небольших, вручную составленных матрицах были проверены:
	- корректность умножения на скаляр
	- корректность умножения на вектор
	- корректность транспонирования
	- корректность сложения матриц

2. Производительные тесты (speed_check.cpp):
	Использованы матрицы следующих размеров:
	- 10000 x 9300 в виде двух штук с плотностями 5% и 25%
	- 4000 x 2000 в виде двух штук с плотностями 5% и 25%
	- 8000 x 20000 в виде двух штук с плотностями 5% и 25%
	
	Для каждой структуры и каждой операции сравнивалось время:
	- параллельной версии
	- последовательной версии
	
## Запуск

Использовались **Windows10**, **VS2019**, **g++ 15.2**, **MSVC для VS2019**

Сборка и запуск проверки валидности операций:

```bash
g++ -fopenmp validity_check.cpp DenseMatrix.cpp COOMatrix.cpp CSRMatrix.cpp CSCMatrix.cpp VecRepr.cpp -o operations_validity.exe

operations_validity.exe
```

Сборка и запуск сравнения времени операций на представленных 6 видах матриц:	

```bash
g++ -fopenmp speed_check.cpp DenseMatrix.cpp COOMatrix.cpp CSRMatrix.cpp CSCMatrix.cpp VecRepr.cpp -o speed_check.exe

speed_check.exe
```

## Формат входа

Для входного формата сравнения времени использовались .txt файлы с записанными матрицами в виде:

```bash
rows cols nnz
 r1   c1   v1
 r2	  c2   v2
 ...  ... ...
rnnz cnnz vnnz
```

Для проверки валидности операций брались готовые матрицы и записывались вручную в файл operations_validity.cpp

## Результаты и анализ

1. Влияние плотности на производительность:
	- 5% плотности - разреженные представления выигрывают на порядки, DenseMatrix работает одинаково для 5% и 25%
	- 25% плотности - разреженные представления все еще значительно быстрее плотного, остальные увеличили время работы в 4-5 раз, что линейно коррелирует с возрастанием плотности

2. Сравнение форматов при 5% и 25% плотности:
	- Умножение на скаляр - CSR и CSC лучше COO на 20-30%, Dense всегда самый медленный, т.к. делает работу над всеми элементами
	- Умножение на вектор - самая показательная операция для разреженных представлений. CSR и CSC - самые быстрые, COO проигрывает им, т.к. не адаптирована под прохождение по строке/столбцу. Dense сильно проигрывает остальным при обеих плотностях
	- Транспонирование - убило CSR и CSC, т.к. в его ходе они должны полностью перестроиться. Для COO - самое быстрое, а для Dense очень хорошо параллелится => показало большое ускорение
	- Сложение матриц - для COO - самая медленная операция - почти всегда худший результат. CSR и CSC работают хорошо, быстрее Dense матриц
	
3. Распараллеливание:
Общие закономерности - ускорение в 1.5-3 раза, иногда 4 раза на больщой Dense матрице. Для разреженных структур на 5% плотности особо роли не играет, т.к. элементов немного, а инициализация OpenMP каждый раз занимает тоже какое-то время. Для 25% уже выигрыш лучше. Возможно, если взять матрицы еще больше 100к x 100к, то и при 5% будет большой прирост, но я не стал такую брать, т.к. потребовалась бы вечность на загрузку ее из файла...

## Краткое описание файлов проекта

1. В папке matrices_txt лежат шаблоны матриц и векторов. Сами матрицы можно скачать с [ГуглДиска](https://drive.google.com/file/d/1Owza023VZacC5u2E6sQ0RlqlOqTHhvzV/view?usp=sharing)
2. В папке results можно найти результаты замера скоростей для представленных типов матриц
3. VecRepr.h / .cpp - утилита для удобства работы с векторами
4. DenseMatrix.h / .cpp - хедер и реализация класса плотных матриц, COOMatrix.h / .cpp - для COO матриц, CSRMatrix.h / .cpp - для CSR матриц, CSCMatrix.h / .cpp - для CSC матриц
5. validity_check.cpp - проверка валидности операций. Для этого я взял небольшие целочисленные матрицы, с которыми вручную (matrixcalc) проделал операции, далее сравнил с тем, что выдают мои классы. Проверял совпадением строковых представлений матриц, в которых каждое значение ДОЛЖНО иметь 2 знака после запятой
6. speed_check.cpp - сравнение времени работы разных операций. Для этого генерировал большие матрицы + векторы и прогонял операции над ними
7. Из файла читал матрицу в COO формате, далее конвертировал в другие представления












